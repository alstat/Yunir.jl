var documenterSearchIndex = {"docs":
[{"location":"man/rhythmic_analysis/#Rhythmic-Analysis","page":"Rhytmic Analysis","title":"Rhythmic Analysis","text":"The prevalence of poetry in Arabic literature necessitates scientific tool to study the rhythmic signatures. Unfortunately, there are no resources for such methodology until the recent work of Asaad [1]. This section will demonstrate the APIs for doing rhythmic analysis based on the methodologies proposed by Asaad [1]. To do this, there are two types of text that will be studied, and these are pre-Islamic poetry and the Holy Qur'an.","category":"section"},{"location":"man/rhythmic_analysis/#Arabic-Poetry","page":"Rhytmic Analysis","title":"Arabic Poetry","text":"The first data is from a well known author, Al-Mutanabbi المتنبّي, who authored several poetry including the titled 'Indeed, every woman with a swaying walk', which will be the basis for this section.","category":"section"},{"location":"man/rhythmic_analysis/#Loading-Data","page":"Rhytmic Analysis","title":"Loading Data","text":"The following codes assigns the said poem of Al-Mutanabbi to a variable poem.\n\nusing Yunir\n@transliterator :default\n\npoem = \"\"\"\n    أَلَا كُلُّ مَاشِيَةِ الخَيْزَلَى؛\n    فِدًى كُلِّ مَاشِيَةِ الهَيْذَبَى؛\n    وَكُلِّ نَجَاةٍ بُجَاوِيَّةٍ،\n    خَنُوفٍ وَمَا بِي حُسْنُ المِشَى؛\n    وَلَكِنَّهُنَّ حِبَالُ الحَيَاةِ،\n    وَكَيْدُ العُدَاةِ وَمَيْطُ الأَذَى؛\n    ضَرَبْتُ بِهَا التِّيهَ ضَرْبَ القِمَا\n    رِ إِمَّا لِهَذَا وَإِمَّا لِذَا؛\n    إِذَا فَزِعَتْ قَدَّمَتْهَا الجِيَادُ،\n    وَبِيضُ السُّيُوفِ وَسُمْرُ القَنَا؛\n    فَمَرَّتْ بِنَخْلٍ وَفِي رَكْبِهَا،\n    عَنِ العَالَمِينَ وَعَنْهُ غِنَى؛\n    وَأَمْسَتْ تُخَيِّرُنَا بِالنَّقَا،\n    بِوَادِي المِيَاهِ وَوَادِي القُرَى؛\n    وَقُلْنَا لَهَا أَيْنَ أَرْضُ العِرَاقِ؟\n    فَقَالَتْ وَنَحْنُ بِتُرْبَانَهَا؛\n    وَهَبَّتْ بِحِسْمَى هُبُوبَ الدَّبُو\n    رِ مُسْتَقْبِلَاتٍ مَهَبَّ الصَّبَا؛\n    رَوَامِي الكِفَافِ وَكِبْدِ الوِهَادِ،\n    وَجَارِ البُوَيْرَةِ وَادِي الغَضَى؛\n    وَجَابَتْ بُسَيْطَةَ جَوْبَ الرِّدَا،\n    بَيْنَ النَّعَامِ وَبَيْنَ المَهَا؛\n    إِلَى عُقْدَةِ الجَوْفِ حَتَّى شَفَتْ،\n    بِمَاءِ الجُرَاوِيِّ بَعْضَ الصَّدَى؛\n    وَلَاحَ لَهَا صَوَرٌ وَالصَّبَاحُ،\n    وَلَاحَ الشَّغُورُ لَهَا وَالضُّحَى؛\n    وَمَسَّى الجُمَيْعِيَّ دِئْدَاؤُهَا،\n    وَغَادَى الأَضَارِعَ ثُمَّ الدَّنَا؛\n    فَيَا لَكَ لَيْلًا عَلَى أَعْكُشٍ،\n    أَحَمَّ البِلَادِ خَفِيَّ الصُّوَى؛\n    وَرَدْنَا الرُّهَيْمَةَ فِي جَوْزِهِ،\n    وَبَاقِيهِ أَكْثَرُ مِمَّا مَضَى؛\n    فَلَمَّا أَنَخْنَا رَكَزْنَا الرِّمَاحَ،\n    بَيْنَ مَكَارِمِنَا وَالعُلَى؛\n    وَبِتْنَا نُقَبِّلُ أَسْيَافَنَا،\n    وَنَمْسَحُهَا مِنْ دِمَاءِ العِدَى؛\n    لِتَعْلَمَ مِصْرُ وَمَنْ بِالعِرَاقِ،\n    وَمَنْ بِالعَوَاصِمِ أَنِّي الفَتَى؛\n    وَأَنِّي وَفَيْتُ وَأَنِّي أَبَيْتُ،\n    وَأَنِّي عَتَوْتُ عَلَى مَنْ عَتَا؛\n    وَمَا كُلُّ مَنْ قَالَ قَوْلًا وَفَى،\n    وَلَا كُلُّ مَنْ سِيمَ خَسْفًا أَبَى؛\n    وَلَا بُدَّ لِلْقَلْبِ مِنْ آلَةٍ،\n    وَرَأْيٍ يُصَدِّعُ صُمَّ الصَّفَا؛\n    وَمَنْ يَكُ قَلْبٌ كَقَلْبِي لَهُ،\n    يَشُقُّ إِلَى العِزِّ قَلْبَ التَّوَى؛\n    وَكُلُّ طَرِيقٍ أَتَاهُ الفَتَى،\n    عَلَى قَدَرِ الرِّجْلِ فِيهِ الخُطَى؛\n    وَنَامَ الخُوَيْدِمُ عَنْ لَيْلِنَا،\n    وَقَدْ نَامَ قَبْلُ عَمًى لَا كَرَى؛\n    وَكَانَ عَلَى قُرْبِنَا بَيْنَنَا،\n    مَهَامِهُ مِنْ جَهْلِهِ وَالعَمَى؛\n    وَمَنْ جَهِلَتْ نَفْسُهُ قَدْرَهُ،\n    رَأَى غَيْرُهُ مِنْهُ مَا لَا يَرَى.\n\"\"\"","category":"section"},{"location":"man/rhythmic_analysis/#Extracting-Syllables","page":"Rhytmic Analysis","title":"Extracting Syllables","text":"Now let's try extracting the syllables for the first line. To do this, let's convert the text into a vector of stanzas of the poem. We therefore split the text on the \";\\n\" separator, where the \\n is the code for line break. The function strip simply removes the whitespaces before and after each stanza.\n\ntexts = map(x -> Ar.(string.(strip(string(x)))), split.(poem, \"\\n\"))\n\nNext is to initialize the syllabification for each stanza, suppose we want to capture the consonant before and after each vowel to represent one syllable. For example, for the word basmala, the syllabification if only the consonant preceding the vowel is considered then we have ba, ma, and la. To specify this configuration for the syllable, we do it as follows:\n\nsyllable = Syllable(1, 0, 10)\n\nHere the first argument represents the number of characters prior to the vowel is considered, the next argument which is 0 is the number of character after the vowel, and 10 in the third argument simply mean how many vowels do we need to capture for each word. So that, 10 here assures us that we capture all vowels of any word because most usually has less than 10 vowels.\n\nr = Syllabification(false, syllable)\n\nThen, the following will syllabicize the first word in the said poem.\n\nr(\n    string(split(texts[1], \" \")[1]), \n    first_word=true, \n    silent_last_vowel=false\n)\n\nThe parameter isarabic ask if the output segment should be in Arabic form. The segment is defined here as the joined slices of the syllables. The first_word parameter checks if the input text is a first word of a sentence or phrase. Finally the last parameter aims to capture the case of silencing the vowel of the last word.\n\nFrom the output above, there are two syllables, the first being أَ and the second is لَا, both are separated with ?.\n\nwarning: Caution\nIt is important to note that syllabification works only on a fully diacritize text as in the input poem here, and that is because each syllable contain a vowel. If not fully diacritize, then the syllabification will consider a syllable with only consonant and no vowel.\n\nSo that, if we want to extract the syllables all lines in the poem, then:\n\n# Process only the first 3 lines for demonstration\nline_syllables = Array[]\nfor line in texts\n    words = Ar.(string.(split(line.text, \" \")))\n\n    word_syllables = Segment[]\n    i = 1\n    for word in words\n        if i === 1\n            push!(word_syllables, r(word, first_word=true))\n        elseif i === length(words)\n            push!(word_syllables, r(word, first_word=false, silent_last_vowel=false))\n        else\n            push!(word_syllables, r(word, first_word=false))\n        end\n        i += 1\n    end\n    push!(line_syllables, word_syllables)\nend\n\nTo extract the syllables of the words in first line of the poem, we run the following code:\n\nline_syllables[1]\n\nAnd for the last line of the poem\n\nline_syllables[end-1]\n\ninfo: Note\nThe indexing is set to end-1 because the last line of the texts variable is a blank line space as seen in the results of the texts variable assigned to the mapping function above.","category":"section"},{"location":"man/rhythmic_analysis/#Visualizing-Last-Syllable","page":"Rhytmic Analysis","title":"Visualizing Last Syllable","text":"This section will visualize the rhythmic pattern for the last syllable of a stanza or line of text, or in the context of the Qur'an last syllable of each verse.\n\nThe LastRecited visualization system provides a powerful way to analyze and visualize the patterns of ending syllables in Arabic texts, particularly useful for studying rhyme schemes in poetry and the Qur'an.","category":"section"},{"location":"man/rhythmic_analysis/#Understanding-Visualization-Variants","page":"Rhytmic Analysis","title":"Understanding Visualization Variants","text":"The visualization system offers three variants (A, B, and C) that show different levels of detail:\n\nVariant A: Shows only the last syllable (2 characters)\nVariant B: Shows two subplots - the syllable and syllable with trailing consonant\nVariant C: Shows three subplots - syllable, syllable with trailing consonant, and syllable with leading and trailing consonants","category":"section"},{"location":"man/rhythmic_analysis/#Basic-Usage-with-Qur'an-Data","page":"Rhytmic Analysis","title":"Basic Usage with Qur'an Data","text":"Let's start with a simple example using Al-Fatihah (the opening chapter of the Qur'an):\n\n# Al-Fatihah in Buckwalter transliteration\nalfatihah_raw = Ar.([\n    \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\",\n    \"ٱلْحَمْدُ لِلَّهِ رَبِّ ٱلْعَٰلَمِينَ\",\n    \"ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\",\n    \"مَٰلِكِ يَوْمِ ٱلدِّينِ\",\n    \"إِيَّاكَ نَعْبُدُ وَإِيَّاكَ نَسْتَعِينُ\",\n    \"ٱهْدِنَا ٱلصِّرَٰطَ ٱلْمُسْتَقِيمَ\",\n    \"صِرَٰطَ ٱلَّذِينَ أَنْعَمْتَ عَلَيْهِمْ غَيْرِ ٱلْمَغْضُوبِ عَلَيْهِمْ وَلَا ٱلضَّآلِّينَ\"\n])\nalfatihah_bw = encode.(alfatihah_raw)","category":"section"},{"location":"man/rhythmic_analysis/#Creating-a-Simple-Visualization-(Variant-A)","page":"Rhytmic Analysis","title":"Creating a Simple Visualization (Variant A)","text":"The simplest visualization shows only the last syllable:\n\nusing CairoMakie # Required for visualization\n\n# Create visualization configuration\nvis = RhythmicVis(LastRecited(A))\n\n# Generate the visualization\nfig, data = vis(alfatihah_bw)\n\n# Extract the data\npositions, syllable_mapping = data[1]\n\nprintln(\"Syllable positions: \", positions)\nprintln(\"Unique syllables: \", keys(syllable_mapping))\n\nfig\n\nIn this example, all verses end with the same syllable \"iy\", showing the consistent rhyme scheme of Al-Fatihah.","category":"section"},{"location":"man/rhythmic_analysis/#Two-Level-Analysis-(Variant-B)","page":"Rhytmic Analysis","title":"Two-Level Analysis (Variant B)","text":"For more detailed analysis, Variant B shows how syllables differ when including the trailing consonant:\n\n# Create variant B visualization\nvis_b = RhythmicVis(LastRecited(B))\n\n# Generate visualization\nfig_b, data_b = vis_b(alfatihah_bw)\n\n# Extract both datasets\npositions1, syllable_map1 = data_b[1]\npositions2, syllable_map2 = data_b[2]\n\nprintln(\"First subplot - syllable only:\")\nprintln(\"  Positions: \", positions1)\nprintln(\"  Unique syllables: \", length(syllable_map1))\n\nprintln(\"\\nSecond subplot - syllable + trailing:\")\nprintln(\"  Positions: \", positions2)\nprintln(\"  Unique syllables: \", length(syllable_map2))\n\nfig_b\n\nThis shows that while all verses have the same core syllable, they vary in the trailing consonant (either \"m\" or \"n\").","category":"section"},{"location":"man/rhythmic_analysis/#Complete-Analysis-(Variant-C)","page":"Rhytmic Analysis","title":"Complete Analysis (Variant C)","text":"The most comprehensive analysis uses Variant C with three subplots:\n\n# Create variant C visualization\nvis_c = RhythmicVis(LastRecited(C))\n\n# Generate visualization with custom styling\nfig_c, data_c = vis_c(alfatihah_bw, color=:blue, linewidth=2)\n\n# Extract all three datasets\n(pos1, map1), (pos2, map2), (pos3, map3) = data_c\n\nprintln(\"Analysis of Al-Fatihah ending patterns:\")\nprintln(\"Subplot 1 (syllable): \", length(map1), \" unique patterns\")\nprintln(\"Subplot 2 (+ trailing): \", length(map2), \" unique patterns\")\nprintln(\"Subplot 3 (leading + trailing): \", length(map3), \" unique patterns\")\n\nfig_c","category":"section"},{"location":"man/rhythmic_analysis/#Analyzing-Poetry","page":"Rhytmic Analysis","title":"Analyzing Poetry","text":"Now let's analyze the poem we loaded earlier to see its rhyme scheme:\n\n# Convert poem lines to Buckwalter encoding\n# Remove empty lines and encode\npoem_lines = filter(x -> length(x) > 0, texts)\npoem_bw = [encode(line) for line in poem_lines]\n\n# Create visualization\nvis_poem = RhythmicVis(LastRecited(C))\nfig_poem, data_poem = vis_poem(poem_bw)\n\nfig_poem","category":"section"},{"location":"man/rhythmic_analysis/#Customizing-the-Visualization","page":"Rhytmic Analysis","title":"Customizing the Visualization","text":"You can customize various aspects of the visualization:\n\nusing Makie\n\n# Create custom figure\ncustom_fig = Figure(resolution=(1200, 800))\n\n# Create visualization with custom parameters\nvis_custom = RhythmicVis(LastRecited(B))\n\n# Generate with custom styling\nfig_styled, data_styled = vis_custom(\n    alfatihah_bw,\n    color=:red,\n    linewidth=3,\n    linestyle=:dash\n)\n\nfig_styled","category":"section"},{"location":"man/rhythmic_analysis/#Extracting-Syllable-Information","page":"Rhytmic Analysis","title":"Extracting Syllable Information","text":"You can also extract syllable information without creating a visualization:\n\n# Extract last syllables directly\nlr = LastRecited(C)\n\nfor (i, text) in enumerate(alfatihah_bw)\n    syllables = last_syllable(lr, text)\n    println(\"Verse $i:\")\n    println(\"  Core syllable: \", syllables[1].syllable.text)\n    println(\"  + trailing: \", syllables[2].syllable.text)\n    println(\"  Leading + trailing: \", syllables[3].syllable.text)\nend","category":"section"},{"location":"man/rhythmic_analysis/#Converting-Syllables-to-Numeric-Positions","page":"Rhytmic Analysis","title":"Converting Syllables to Numeric Positions","text":"The to_numbers function converts syllables to numeric positions for plotting:\n\n# Collect syllables from all verses\nsyllables = [last_syllable(LastRecited(A), text)[1] for text in alfatihah_bw]\n\n# Convert to numeric positions\npositions, mapping = to_numbers(syllables)\n\nprintln(\"Positions: \", positions)\nprintln(\"\\nSyllable mapping:\")\nfor (syll, pos) in mapping\n    println(\"  Position $pos: \", syll.syllable.text)\nend","category":"section"},{"location":"man/rhythmic_analysis/#Practical-Applications","page":"Rhytmic Analysis","title":"Practical Applications","text":"","category":"section"},{"location":"man/rhythmic_analysis/#1.-Studying-Rhyme-Consistency","page":"Rhytmic Analysis","title":"1. Studying Rhyme Consistency","text":"Check if a poem maintains consistent rhyme:\n\n# Analyze first 10 lines\nsample_lines = poem_bw[1:min(10, length(poem_bw))]\nvis_rhyme = RhythmicVis(LastRecited(A))\nfig_rhyme, data_rhyme = vis_rhyme(sample_lines)\n\npositions, _ = data_rhyme[1]\nis_consistent = all(p == positions[1] for p in positions)\n\nprintln(\"Rhyme consistency: \", is_consistent ? \"Consistent\" : \"Varies\")\nfig_rhyme","category":"section"},{"location":"man/rhythmic_analysis/#2.-Comparing-Different-Texts","page":"Rhytmic Analysis","title":"2. Comparing Different Texts","text":"Compare rhyme patterns between different surahs or poems:\n\n# Create two different visualizations for comparison\nusing CairoMakie\n\n# Al-Fatihah\nvis1 = RhythmicVis(LastRecited(B))\nfig1, _ = vis1(alfatihah_bw, color=:blue)\n\n# You can create similar visualization for another surah\n# and compare the patterns side by side","category":"section"},{"location":"man/rhythmic_analysis/#3.-Statistical-Analysis","page":"Rhytmic Analysis","title":"3. Statistical Analysis","text":"Extract statistics about syllable distribution:\n\n# Analyze syllable variety in Al-Fatihah\nlr_analysis = LastRecited(C)\nall_syllables = [last_syllable(lr_analysis, text) for text in alfatihah_bw]\n\n# Count unique patterns at each level\nlevel1_unique = length(unique([s[1] for s in all_syllables]))\nlevel2_unique = length(unique([s[2] for s in all_syllables]))\nlevel3_unique = length(unique([s[3] for s in all_syllables]))\n\nprintln(\"Statistical Analysis:\")\nprintln(\"  Total verses: \", length(alfatihah_bw))\nprintln(\"  Unique syllables (core): \", level1_unique)\nprintln(\"  Unique syllables (+ trailing): \", level2_unique)\nprintln(\"  Unique syllables (full): \", level3_unique)","category":"section"},{"location":"man/rhythmic_analysis/#Advanced-Usage:-Custom-Default-Parameters","page":"Rhytmic Analysis","title":"Advanced Usage: Custom Default Parameters","text":"When creating visualizations, you can set custom defaults:\n\n# Create visualization with default constructor\nvis_default = RhythmicVis(LastRecited())  # Uses variant A by default\n\n# Create with explicit variant\nvis_explicit = RhythmicVis(LastRecited(B))","category":"section"},{"location":"man/rhythmic_analysis/#Understanding-the-Output","page":"Rhytmic Analysis","title":"Understanding the Output","text":"The visualization system returns:\n\nFigure: A Makie figure object that can be displayed, saved, or further customized\nData: A tuple containing:\nPositions: Integer array indicating which unique syllable each text uses\nMapping: Dictionary mapping each unique syllable to its numeric position\n\nThis data structure allows you to:\n\nRecreate visualizations with custom styling\nPerform statistical analysis\nExport data for use in other tools","category":"section"},{"location":"man/rhythmic_analysis/#Tips-and-Best-Practices","page":"Rhytmic Analysis","title":"Tips and Best Practices","text":"Use Variant A for quick overview of basic rhyme patterns\nUse Variant B when you need to distinguish similar-sounding endings\nUse Variant C for comprehensive phonetic analysis\nCustomize colors to distinguish between different texts or sections\nSave figures using save(\"output.png\", fig) for documentation","category":"section"},{"location":"man/rhythmic_analysis/#Working-with-Large-Texts","page":"Rhytmic Analysis","title":"Working with Large Texts","text":"For analyzing entire surahs or long poems:\n\n# Process in batches if needed\nfunction analyze_batches(texts, batch_size=50)\n    results = []\n    for i in 1:batch_size:length(texts)\n        batch = texts[i:min(i+batch_size-1, length(texts))]\n        vis = RhythmicVis(LastRecited(A))\n        fig, data = vis(batch)\n        push!(results, (fig, data))\n    end\n    return results\nend\n\n# Example: analyze in batches\n# batches = analyze_batches(long_text_array)","category":"section"},{"location":"man/rhythmic_analysis/#Joseph-Schillinger's-Rhythmic-Graph","page":"Rhytmic Analysis","title":"Joseph Schillinger's Rhythmic Graph","text":"Joseph Schillinger's rhythmic graph theory provides a powerful framework for analyzing and visualizing rhythmic patterns in Arabic text, particularly for Quranic recitation (tajweed). This approach maps vowel patterns to rhythmic states with specific durations, creating a quantitative representation of rhythmic flow.","category":"section"},{"location":"man/rhythmic_analysis/#Understanding-Rhythmic-States","page":"Rhytmic Analysis","title":"Understanding Rhythmic States","text":"In Schillinger's theory, each vowel pattern maps to a rhythmic state with a duration value. For Arabic/Buckwalter text, we typically distinguish between:\n\nShort vowels (duration = 1): kasra i, fatha a, damma u, and tanween F, N, K\nLong vowels (duration = 2): kasra+yaa iy, fatha+alif aA, damma+waw uw, and alif khanjariya a`\nMaddah (duration = 4 or more): elongated vowel ^","category":"section"},{"location":"man/rhythmic_analysis/#Setting-Up-the-Timing-Dictionary","page":"Rhytmic Analysis","title":"Setting Up the Timing Dictionary","text":"The first step is to create a timing dictionary that maps Buckwalter vowel patterns to rhythmic states:\n\nusing Yunir\nusing CairoMakie\n\n# Define tajweed timings based on Quranic recitation rules\ntajweed_timings = Dict{Bw,RState}(\n    # Short vowels (1 beat)\n    Bw(\"i\") => RState(1, \"short\"),    # kasra\n    Bw(\"a\") => RState(1, \"short\"),    # fatha\n    Bw(\"u\") => RState(1, \"short\"),    # damma\n    Bw(\"F\") => RState(1, \"short\"),    # fatha tanween\n    Bw(\"N\") => RState(1, \"short\"),    # damma tanween\n    Bw(\"K\") => RState(1, \"short\"),    # kasra tanween\n\n    # Long vowels (2 beats)\n    Bw(\"iy\") => RState(2, \"long\"),    # kasra + yaa\n    Bw(\"aA\") => RState(2, \"long\"),    # fatha + alif\n    Bw(\"uw\") => RState(2, \"long\"),    # damma + waw\n    Bw(\"a`\") => RState(2, \"long\"),    # fatha + alif khanjariya\n\n    # Maddah (4 beats or more)\n    Bw(\"^\") => RState(4, \"maddah\")    # maddah elongation\n)\n\nThe RState structure takes two parameters:\n\nstate::Int: The duration/timing value\ndescription::String: A descriptive label","category":"section"},{"location":"man/rhythmic_analysis/#Creating-a-Schillinger-Analyzer","page":"Rhytmic Analysis","title":"Creating a Schillinger Analyzer","text":"Once you have defined your timing dictionary, create a Schillinger object:\n\nschillinger = Schillinger(tajweed_timings)","category":"section"},{"location":"man/rhythmic_analysis/#Analyzing-Text-with-rhythmic_states","page":"Rhytmic Analysis","title":"Analyzing Text with rhythmic_states","text":"The rhythmic_states function analyzes Buckwalter-encoded Arabic texts and converts them into rhythmic states. Let's analyze verses from Al-Fatihah:\n\n# Define Al-Fatihah in Buckwalter encoding\nbw_texts = [\n    Bw(\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"{loHamodu lil~ahi rab~i {loEa`lamiyna\"),\n    Bw(\"{lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"ma`liki yawomi {ld~iyni\"),\n    Bw(\"<iy~aAka naEobudu wa<iy~aAka nasotaEiynu\"),\n    Bw(\"{hodinaA {lS~ira`Ta {lomusotaqiyma\"),\n    Bw(\"Sira`Ta {l~a*iyna >anoEamota Ealayohimo gayori {lomagoDuwbi Ealayohimo walaA {lD~aA^l~iyna\")\n]\n\n# Analyze the rhythmic patterns\nstates = rhythmic_states(schillinger, bw_texts)\n\n# Display information about the first verse\nprintln(\"First verse: $(bw_texts[1].text)\")\nprintln(\"Number of rhythmic states: $(length(states[1]))\")\nprintln(\"First few states:\")\nfor (i, state) in enumerate(states[1][1:min(5, length(states[1]))])\n    println(\"  State $i: duration=$(state.state), type=$(state.label)\")\nend\n\nThe rhythmic_states function:\n\nSplits each text into individual words\nApplies syllabification to each word with appropriate boundary conditions:\nFirst word: first_word=true, silent_last_vowel=false\nLast word: first_word=false, silent_last_vowel=true\nMiddle words: first_word=false, silent_last_vowel=false\nExtracts vowel patterns from each syllable\nMaps each vowel pattern to its corresponding rhythmic state using the timing dictionary","category":"section"},{"location":"man/rhythmic_analysis/#Visualizing-Rhythmic-Patterns","page":"Rhytmic Analysis","title":"Visualizing Rhythmic Patterns","text":"The vis function creates a staircase plot visualization of the rhythmic patterns:\n\n# Create visualization\nfig = vis(states, Figure(size=(900, 900)),\n         \"Al-Fatihah Rhythmic Analysis\",\n         \"Time in Beats\",\n         \"Verse\")\n\nfig\n\nThe visualization parameters:\n\nrhythms::Vector{Vector{RState}}: The output from rhythmic_states\nfig::Makie.Figure: Optional pre-existing Figure (defaults to new Figure(size=(900,900)))\ntitle::String: Plot title (defaults to \"Title\")\nxlabel::String: X-axis label (defaults to \"Time in Seconds\")\nylabel::String: Y-axis label (defaults to \"Line\")\n\nThe staircase plot shows:\n\nEach subplot represents one text/verse\nSteps alternate between levels (0 and 1) to show rhythmic transitions\nStep width corresponds to the duration of each rhythmic state\nAll subplots share the same x-axis for easy comparison","category":"section"},{"location":"man/rhythmic_analysis/#Analyzing-Specific-Verses","page":"Rhytmic Analysis","title":"Analyzing Specific Verses","text":"You can analyze specific verses or subsets of text:\n\n# Analyze only the 4th verse\nverse4 = rhythmic_states(schillinger, bw_texts[4:4])\n\nprintln(\"Verse 4: $(bw_texts[4].text)\")\nprintln(\"Total beats: $(sum(s.state for s in verse4[1]))\")\nprintln(\"Number of states: $(length(verse4[1]))\")\n\n# Create visualization for just this verse\nfig_verse4 = vis(verse4, Figure(size=(600, 300)),\n                 \"Verse 4 Analysis\",\n                 \"Time in Beats\",\n                 \"\")\n\nfig_verse4","category":"section"},{"location":"man/rhythmic_analysis/#Comparing-Rhythmic-Patterns","page":"Rhytmic Analysis","title":"Comparing Rhythmic Patterns","text":"You can compare rhythmic patterns across different verses:\n\n# Analyze verses 1-3\nfirst_three = rhythmic_states(schillinger, bw_texts[1:3])\n\n# Calculate total duration for each verse\nfor (i, verse_states) in enumerate(first_three)\n    total_duration = sum(s.state for s in verse_states)\n    short_count = count(s -> s.label == \"short\", verse_states)\n    long_count = count(s -> s.label == \"long\", verse_states)\n    maddah_count = count(s -> s.label == \"maddah\", verse_states)\n\n    println(\"Verse $i:\")\n    println(\"  Total duration: $total_duration beats\")\n    println(\"  Short vowels: $short_count\")\n    println(\"  Long vowels: $long_count\")\n    println(\"  Maddah: $maddah_count\")\nend\n\n# Visualize comparison\nfig_compare = vis(first_three, Figure(size=(900, 600)),\n                  \"First Three Verses Comparison\",\n                  \"Time in Beats\",\n                  \"Verse\")\n\nfig_compare","category":"section"},{"location":"man/rhythmic_analysis/#Custom-Timing-Schemes","page":"Rhytmic Analysis","title":"Custom Timing Schemes","text":"You can define custom timing schemes for different recitation styles or analytical purposes:\n\n# Example: Simplified timing (only short vs long)\nsimple_timings = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"),\n    Bw(\"a\") => RState(1, \"short\"),\n    Bw(\"u\") => RState(1, \"short\"),\n    Bw(\"F\") => RState(1, \"short\"),\n    Bw(\"N\") => RState(1, \"short\"),\n    Bw(\"K\") => RState(1, \"short\"),\n    Bw(\"iy\") => RState(2, \"long\"),\n    Bw(\"aA\") => RState(2, \"long\"),\n    Bw(\"uw\") => RState(2, \"long\"),\n    Bw(\"a`\") => RState(2, \"long\"),\n    Bw(\"^\") => RState(2, \"long\")  # Treat maddah as regular long\n)\n\nschillinger_simple = Schillinger(simple_timings)\nstates_simple = rhythmic_states(schillinger_simple, bw_texts[1:3])\n\nfig_simple = vis(states_simple, Figure(size=(900, 600)),\n                \"Simplified Timing Analysis\",\n                \"Time in Beats\",\n                \"Verse\")\n\nfig_simple","category":"section"},{"location":"man/rhythmic_analysis/#Working-with-Arabic-Script","page":"Rhytmic Analysis","title":"Working with Arabic Script","text":"The rhythmic_states function also accepts Arabic (Ar) text, automatically converting it to Buckwalter encoding:\n\n# Define texts in Arabic script\nar_texts = [\n    Ar(\"بِسْمِ اللَّهِ الرَّحْمَٰنِ الرَّحِيمِ\"),\n    Ar(\"الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ\")\n]\n\n# Analyze directly\nstates_ar = rhythmic_states(schillinger, ar_texts)\n\nprintln(\"Analyzed $(length(states_ar)) verses from Arabic text\")","category":"section"},{"location":"man/rhythmic_analysis/#Practical-Applications-2","page":"Rhytmic Analysis","title":"Practical Applications","text":"","category":"section"},{"location":"man/rhythmic_analysis/#1.-Recitation-Timing-Analysis","page":"Rhytmic Analysis","title":"1. Recitation Timing Analysis","text":"Calculate total recitation time for verses:\n\n# Assuming 1 beat = 0.3 seconds in typical recitation\nbeat_duration = 0.3\n\nall_states = rhythmic_states(schillinger, bw_texts)\n\nprintln(\"Estimated recitation times:\")\nfor (i, verse_states) in enumerate(all_states)\n    total_beats = sum(s.state for s in verse_states)\n    time_seconds = total_beats * beat_duration\n    println(\"  Verse $i: $(total_beats) beats ≈ $(round(time_seconds, digits=1))s\")\nend","category":"section"},{"location":"man/rhythmic_analysis/#2.-Rhythmic-Complexity-Analysis","page":"Rhytmic Analysis","title":"2. Rhythmic Complexity Analysis","text":"Identify verses with the most complex rhythmic patterns:\n\ncomplexity_scores = []\n\nfor (i, verse_states) in enumerate(all_states)\n    # Count transitions between different rhythmic states\n    transitions = 0\n    for j in 1:length(verse_states)-1\n        if verse_states[j].state != verse_states[j+1].state\n            transitions += 1\n        end\n    end\n\n    push!(complexity_scores, (i, transitions, length(verse_states)))\n    println(\"Verse $i: $transitions transitions, $(length(verse_states)) total states\")\nend","category":"section"},{"location":"man/rhythmic_analysis/#3.-Finding-Rhythmic-Patterns","page":"Rhytmic Analysis","title":"3. Finding Rhythmic Patterns","text":"Identify repeated rhythmic sequences:\n\n# Extract rhythmic signature (sequence of durations)\nfor (i, verse_states) in enumerate(all_states[1:3])\n    signature = [s.state for s in verse_states]\n    println(\"Verse $i signature: $(signature[1:min(10, length(signature))])...\")\nend","category":"section"},{"location":"man/rhythmic_analysis/#Important-Notes","page":"Rhytmic Analysis","title":"Important Notes","text":"warning: Text Requirements\nInput text must be fully diacritized (include all vowel markings)\nIncomplete diacritization will result in missing rhythmic states\nThe syllabification algorithm relies on vowel markers to identify syllable boundaries\n\ntip: Timing Dictionary Coverage\nEnsure your timing dictionary includes all vowel patterns present in your text\nIf a vowel pattern is missing from the dictionary, a KeyError will be raised\nThe standard tajweed timing dictionary covers most Quranic texts\n\nnote: Performance\nFor large texts, consider analyzing in batches\nThe visualization becomes cluttered with many verses; consider splitting into smaller groups\nEach subplot is linked on the x-axis for easy comparison","category":"section"},{"location":"man/rhythmic_analysis/#Complete-Example:-Full-Analysis-Pipeline","page":"Rhytmic Analysis","title":"Complete Example: Full Analysis Pipeline","text":"Here's a complete example analyzing Al-Fatihah:\n\n# 1. Set up timing dictionary\ntajweed = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"), Bw(\"a\") => RState(1, \"short\"),\n    Bw(\"u\") => RState(1, \"short\"), Bw(\"F\") => RState(1, \"short\"),\n    Bw(\"N\") => RState(1, \"short\"), Bw(\"K\") => RState(1, \"short\"),\n    Bw(\"iy\") => RState(2, \"long\"), Bw(\"aA\") => RState(2, \"long\"),\n    Bw(\"uw\") => RState(2, \"long\"), Bw(\"a`\") => RState(2, \"long\"),\n    Bw(\"^\") => RState(4, \"maddah\")\n)\n\n# 2. Create analyzer\nanalyzer = Schillinger(tajweed)\n\n# 3. Prepare texts (Al-Fatihah)\nfatihah = [\n    Bw(\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"{loHamodu lil~ahi rab~i {loEa`lamiyna\"),\n    Bw(\"{lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"ma`liki yawomi {ld~iyni\"),\n    Bw(\"<iy~aAka naEobudu wa<iy~aAka nasotaEiynu\"),\n    Bw(\"{hodinaA {lS~ira`Ta {lomusotaqiyma\"),\n    Bw(\"Sira`Ta {l~a*iyna >anoEamota Ealayohimo gayori {lomagoDuwbi Ealayohimo walaA {lD~aA^l~iyna\")\n]\n\n# 4. Analyze rhythmic patterns\nrhythms = rhythmic_states(analyzer, fatihah)\n\n# 5. Generate statistics\nprintln(\"Al-Fatihah Rhythmic Analysis\")\nprintln(\"=\"^40)\nfor (i, r) in enumerate(rhythms)\n    beats = sum(s.state for s in r)\n    println(\"Verse $i: $(beats) beats, $(length(r)) states\")\nend\n\n# 6. Create visualization\nfinal_fig = vis(rhythms, Figure(size=(1000, 1000)),\n               \"Al-Fatihah - Complete Rhythmic Analysis\",\n               \"Time (Beats)\",\n               \"Verse Number\")\n\nfinal_fig","category":"section"},{"location":"man/rhythmic_analysis/#References","page":"Rhytmic Analysis","title":"References","text":"A.-A. B. Asaad. Text Analytics of the Qur'ān. Master's thesis, University of the Philippines (06 2025).\n\n\n\n","category":"section"},{"location":"man/symmetry_analysis/#Symmetric-Analysis","page":"Symmetry Analysis","title":"Symmetric Analysis","text":"The work of Farrin [2]","category":"section"},{"location":"man/symmetry_analysis/#References","page":"Symmetry Analysis","title":"References","text":"R. Farrin. Structure and Qur'anic Interpretation: A Study of Symmetry and Coherence in Islam's Holy Text. Islamic Encounter (White Cloud Press, 2014).\n\n\n\n","category":"section"},{"location":"man/text_alignment/#Text-Alignment","page":"Text Alignment","title":"Text Alignment","text":"Text alignment is used for pairwise comparison of texts (e.g. books), with the aim of checking for deletions, insertions, matches and mismatches in the target texts relative to a reference texts. This is the same task as sequence alignment of two DNA sequence as in Biology. Indeed, Yunir.jl supports this by extending the BioAlignments.jl APIs  to sequence of Arabic texts. Yunir.jl uses align function for aligning two texts.","category":"section"},{"location":"man/text_alignment/#How-it-works","page":"Text Alignment","title":"How it works","text":"The way it works is that, BioAlignments.jl requires a Roman characters as input for pairwise alignment. Therefore, any Arabic characters must first be transliterated to Roman characters. This is possible using Yunir.jl's encode function. The resulting alignment, which is in Roman characters, is then transliterated back to Arabic for easy interpretation.","category":"section"},{"location":"man/text_alignment/#KITAB-project's-text-reuse","page":"Text Alignment","title":"KITAB project's text reuse","text":"We will consider a simple example based on \"text reuse\" case study of KITAB project. The following are portions of two books with IDs Shamela0012129-ara1 and Shamela0023790-ara1 which was detected by \"passim\" (the tool used by KITAB project) as similar. The goal is to compare the two input texts by aligning the characters, and see the similarity based on matches, mismatches, deletions and insertions of characters. In the example texts below, we'll confirm the matches and see how Yunir.jl's APIs work on text alignment.\n\n<table>\n    <thead>\n        <th>Shamela0012129-ara1</th>\n        <th>Shamela0023790-ara1</th>\n    </thead>\n    <tbody>\n        <tr>\n            <td>خرج مع ابي بكر الصديق رضي الله عنه في تجارة الي بصري ومعهم نعيمان وكان نعيمان ممن شهد——- بدرا ايضا وك——-ان علي الزاد فقال له سويبط———– اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط -تشترون مني عبدا قا—لوا نعم فقال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذه المقالة تركتموه فلا تفسدوا علي عبدي قا-لوا بل نشتريه منك فاشتروه بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا ف—————قال نعيمان ان هذا يستهزء بكم واني حر فقالوا قد عرفنا –خبرك وانطلقوا به فلما جاء ابو بكر -اخبروه فاتبعهم ورد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه من ذلك حولا</td>\n            <td>خرج— ابو بكر——————– في تجارة——— ومعه- نعيمان وسويبط بن حرملة وكانا شهدا بدر—–ا وكان نعيمان علي الزاد فقال له سويبط وكان مزاحا اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط اتشترون مني عبدا لي قالوا نعم ق-ال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذه المقالة تركتموه فلا تفسدوا علي عبدي فقالوا بل نشتريه منك——– بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا وعمامة واشتروه فقال نعيمان ان هذا يستهزء بكم واني حر قا-لوا قد اخبرنا بخبرك وانطلقوا به و—-جاء ابو بكر فاخبروه فاتبعهم فرد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه منهما- حول</td>\n        </tr>\n    </tbody>\n</table>","category":"section"},{"location":"man/text_alignment/#Data-processing","page":"Text Alignment","title":"Data processing","text":"To have a quality output, we will need to process the texts to remove unnecessary noise. First, we need to remove all non-Arabic characters. To start with, the following will input the two candidate texts:\n\nusing Yunir\n@transliterator :default\n\nshamela0012129 = Ar(\"خرج مع ابي بكر الصديق رضي الله عنه في تجارة الي بصري ومعهم نعيمان وكان نعيمان ممن شهد——- بدرا ايضا وك——-ان علي الزاد فقال له سويبط———– اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط -تشترون مني عبدا قا—لوا نعم فقال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذه المقالة تركتموه فلا تفسدوا علي عبدي قا-لوا بل نشتريه منك فاشتروه بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا ف—————قال نعيمان ان هذا يستهزء بكم واني حر فقالوا قد عرفنا –خبرك وانطلقوا به فلما جاء ابو بكر -اخبروه فاتبعهم ورد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه من ذلك حولا\");\nshamela0023790 = Ar(\"خرج— ابو بكر——————– في تجارة——— ومعه- نعيمان وسويبط بن حرملة وكانا شهدا بدر—–ا وكان نعيمان علي الزاد فقال له سويبط وكان مزاحا اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط اتشترون مني عبدا لي قالوا نعم ق-ال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذه المقالة تركتموه فلا تفسدوا علي عبدي فقالوا بل نشتريه منك——– بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا وعمامة واشتروه فقال نعيمان ان هذا يستهزء بكم واني حر قا-لوا قد اخبرنا بخبرك وانطلقوا به و—-جاء ابو بكر فاخبروه فاتبعهم فرد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه منهما- حول\");\n\nNext, we remove the non-Arabic characters like the dashes using the clean function:\n\nshamela0012129_cln = clean(shamela0012129)\nshamela0023790_cln = clean(shamela0023790)\n\ntips: Tips\nThe clean function removes the non-Arabic characters through RegEx or Regular Expression, which is set at the third parameter of the function. That is, clean(shamela0012129) is actually equivalent to:clean(shamela0012129; replace_non_ar=\"\", target_regex=r\"[A-Za-z0-9\\(:×\\|\\–\\[\\«\\»\\]~\\)_@./#&+\\—-]*\")In case there are still non-Arabic characters not captured using the default regex, simply insert it to the default pattern.\n\nwarning: Caution\nIt is important that all non-Arabic characters be removed since any special character might be transliterated to a particular Arabic character once transliterating the output back to Arabic, and the result might mislead. See the section \"How it works\" above.\n\nNext, we need to normalize the word Allah, الله, into a single Unicode U+FDF2. This is because this word or name consist of 4 consonants, but most software assigns this into a single Unicode when detected, and hence it is better to convert it in the first place. This is also true with Lam-Alif, ﻻ, composed of two letters but we can assign it to a single Unicode U+FEFB. To do this, we define a mapping of these characters for the normalizer and then use it to normalize the input texts.\n\nmapping = Dict(\n    \"الله\" => \"ﷲ\",\n    \"لا\" => \"ﻻ\"\n);\nshamela0012129_nrm = normalize(shamela0012129_cln, mapping)\nshamela0023790_nrm = normalize(shamela0023790_cln, mapping)","category":"section"},{"location":"man/text_alignment/#Encoding","page":"Text Alignment","title":"Encoding","text":"As emphasized above, Yunir.jl is based on BioAlignments.jl APIs to do the pairwise alignment, and BioAlignments.jl requires  a Roman input character. Therefore, the input Arabic texts need to be encoded or transliterated to Roman characters.\n\nshamela0012129_enc = encode(shamela0012129_nrm)\nshamela0023790_enc = encode(shamela0023790_nrm)","category":"section"},{"location":"man/text_alignment/#Alignment","page":"Text Alignment","title":"Alignment","text":"Finally, we can do the alignment as follows:\n\nres1 = align(shamela0012129_enc, shamela0023790_enc);\nres1\n\nUnfortunately, many software and text editors including the Julia REPL have default left-to-right printing, and hence the alignment above is not clear. What you can do is to copy the output above and paste it into a text editor with Arabic Monospace font (e.g. Kawkab font), and set it to right-justified or set the text direction to right-to-left (RTL). Here is the result under the Notepad++ (after setting the text direction to RTL):\n\n(Image: Alignment-Output-in-Text-Editor)\n\nThe result of the alignment is a list of groups of reference text indicated by the Arabic  character ١, and the target texts indicated by the Arabic character ٢. \n\nnote: Definitions\nMatch, if the characters of reference and target did match, a Alif (i.e., ا) between their rows is placed. \nDeletion, if a tatweel (i.e., \"ـ\") is present in the target text, it means those tatweels represent the deletion of characters from the reference text. \nInsertion, if a tatweel is present in the reference text, it means an insertion of characters was done in the target text. \nMismatch, if both characters of target and reference texts did not match, a space is inserted between their rows.\n\nnote: Note\nIf we did not normalize the word \"الله\" into a single character, there would be four Alif if all letters did match, but because most software prints this as a single character, then there will be four Alif for a single character, and this will make the output confusing to readers. This is true for لا as well.","category":"section"},{"location":"man/text_alignment/#Alignment-in-Buckwalter","page":"Text Alignment","title":"Alignment in Buckwalter","text":"We can actually extract the encoded version, which is in extended Buckwalter transliteration mapping. This can be accessed via the .alignment property of the res above. That is,\n\nres1.alignment\n\nThis is the same with the previous result above, but this one is the Buckwalter encoded Arabic input.\n\nThe number in the left side is the index of the first character in the row, whereas the number in the right side is the index of the last character in the row.","category":"section"},{"location":"man/text_alignment/#Alignment-statistics","page":"Text Alignment","title":"Alignment statistics","text":"From the results above, we can extract the score of the alignment which is a  distance measure between the reference and the target texts. The lower the score the similar the two texts therefore.\n\nscore(res1)\n\nOther statistics are as follows\n\ncount_matches(res1)\ncount_mismatches(res1)\ncount_insertions(res1)\ncount_deletions(res1)\ncount_aligned(res1)","category":"section"},{"location":"man/text_alignment/#Multiple-Alignments","page":"Text Alignment","title":"Multiple Alignments","text":"At times, especially when working with books, the input texts are long enough that it becomes computationally expensive to do the alignment directly. A simple solution is to partition the input  texts into parts and do the alignment, pairing the texts by permutation. For example, in the KITAB's text reuse use case the books are partitioned into \"milestone\" which is indicated by a prefix ms in the texts. To mimick this, we'll add ms into the  shamela0012129 and shamela0023790 as follows:\n\nshamela0012129 = Ar(\"خرج مع ابي بكر الصديق رضي الله عنه في تجارة الي بصري ومعهم نعيمان وكان نعيمان ممن شهد——- بدرا ايضا وك——-ان علي الزاد فقال له سويبط———– اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط -تشترون مني عبدا قا—لوا نعم فقال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذهmsتركتموه فلا تفسدوا علي عبدي قا-لوا بل نشتريه منك فاشتروه بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا ف—————قال نعيمان ان هذا يستهزء بكم واني حر فقالوا قد عرفنا –خبرك وانطلقوا به فلما جاء ابو بكر -اخبروه فاتبعهم ورد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه من ذلك حولا\");\nshamela0023790 = Ar(\"خرج— ابو بكر——————– في تجارة——— ومعه- نعيمان وسويبط بن حرملة وكانا شهدا بدر—–ا وكان نعيمان علي الزاد فقال له سويبط وكان مزاحا اطعمني فقال حتي يجء ابو بكر فقال اما والله لاغيظنك فمروا بقوم فقال لهم سويبط اتشترون مني عبدا لي قالوا نعم ق-ال انه عبد له كلام وهو قاءل لكم اني حر فان كنتم اذا قال لكم هذه المقالة تركتموهmsفلا تفسدوا علي عبدي فقالوا بل نشتريه منك——– بعشر قلاءص ثم جاءوا فوضعوا في عنقه حبلا وعمامة واشتروه فقال نعيمان ان هذا يستهزء بكم واني حر قا-لوا قد اخبرنا بخبرك وانطلقوا به و—-جاء ابو بكر فاخبروه فاتبعهم فرد عليهم القلاءص واخذه فلما قدموا علي النبي صلي الله عليه وسلم اخبروه فضحك هو واصحابه منهما- حول\");\n\nWe will then split this into milestones,\n\nshamela0012129 = Ar.(string.(split(shamela0012129, \"ms\")))\nshamela0023790 = Ar.(string.(split(shamela0023790, \"ms\")))\n\nThen as before, we clean the splitted texts:\n\nshamela0012129_cln = clean.(shamela0012129)\nshamela0023790_cln = clean.(shamela0023790)\n\nnote: Note\nIn Julia, we suffix the name of the function with . to broadcast the function to each item of the list. In this case, we clean each splitted texts.\n\nNext, we normalize the characters as before:\n\nmapping = Dict(\n    \"الله\" => \"ﷲ\",\n    \"لا\" => \"ﻻ\"\n);\nshamela0012129_nrm = map(x -> normalize(x, mapping), shamela0012129_cln)\nshamela0023790_nrm = map(x -> normalize(x, mapping), shamela0023790_cln)\n\nAnd we encode them as follows\n\nshamela0012129_enc = encode.(shamela0012129_nrm)\nshamela0023790_enc = encode.(shamela0023790_nrm)\n\nFinally, we run the alignment.\n\nres2, scr = align(shamela0012129_enc, shamela0023790_enc);\n\nNote that if the input texts are Array or Matrix the align function returns a tuple, comprising of the result of the alignment in Matrix, and the corresponding scores in Matrix.\n\nHere is the score of the comparison, where the rows correspond to the index of the partitions of the reference text, and the  columns correspond to the index of the partitions of the target text.\n\nscr\n\nThe corresponding result of the score is also a Matrix, but it is huge since each cell of the matrix correspond to the result of the alignment and printing it would be difficult to understand. It is therefore better to simply index the Matrix to view only part of it.\n\nFor example, the corresponding result of the score in the first row first column is given below\n\nres2[1,1] # result of the score scr[1,1]\n\nFor the result of the score in the second row first column, we have\n\nres2[2,1] # result of the score scr[2,1]\n\nFinally, as before we can extract the statistics for each result:\n\ncount_matches(res2[2,1])\ncount_mismatches(res2[2,1])\ncount_insertions(res2[2,1])\ncount_deletions(res2[2,1])\ncount_aligned(res2[2,1])","category":"section"},{"location":"man/text_alignment/#Visualization","page":"Text Alignment","title":"Visualization","text":"In this section, we are going to display the alignment by plotting the results.\n\nf, a, xys = plot(res1, :matches, nchars=60)\na[1].xlabel = \"Shamela0023790\"\na[1].xlabelsize = 20\na[1].xticks = 0:2:unique(xys[1][1])[end]\na[3].xlabel = \"Shamela0012129\"\na[3].xlabelsize = 20\na[3].xticks = 0:2:unique(xys[2][1])[end]\nf\n\nThe figure above is divided into three subplots arranged in rows. You can think of the figure as two input text displayed in horizontal (i.e, sideways) orientation. In this orientation, the x-axis becomes the rows of the texts, that is, you can think of the x-axis as the rows of the texts in the book. In this case, we have two books, the reference and the target books. Each dot in reference and target corresponds to the characters that have matched. The lines and curves in the middle (colored in red) represent the connections of the rows of the texts where the matched happened. Further, the y-axis correspond to the length of the rows, in this case 60 characters per row. As you can see, the top tick label of the y-axis is 0 and the bottom tick label of the y-axis is 60, this is because the writing of Arabic is right-to-left, and so we can think of the 0th-tick at the top as the starting index of the first character in both texts, and the row ends at the 60th-tick at the bottom.\n\nWe added further customization to the plot, readers are encouraged to explore the API.\n\nAs for the plot of insertions of characters, we have:\n\nf, a, xys = plot(res1, :insertions, nchars=60)\na[1].xlabel = \"Shamela0023790\"\na[1].xlabelsize = 20\na[1].xticks = 0:2:unique(xys[1][1])[end]\na[3].xlabel = \"Shamela0012129\"\na[3].xlabelsize = 20\na[3].xticks = 0:2:unique(xys[2][1])[end]\nf\n\nFor deletions, we have:\n\nf, a, xys = plot(res1, :deletions, nchars=60)\na[1].xlabel = \"Shamela0023790\"\na[1].xlabelsize = 20\na[1].xticks = 0:2:unique(xys[1][1])[end]\na[3].xlabel = \"Shamela0012129\"\na[3].xlabelsize = 20\na[3].xticks = 0:2:unique(xys[2][1])[end]\nf\n\nAnd for mismatches, we have\n\nf, a, xys = plot(res1, :mismatches, nchars=60)\na[1].xlabel = \"Shamela0023790\"\na[1].xlabelsize = 20\na[1].xticks = 0:2:unique(xys[1][1])[end]\na[3].xlabel = \"Shamela0012129\"\na[3].xlabelsize = 20\na[3].xticks = 0:2:unique(xys[2][1])[end]\nf","category":"section"},{"location":"man/text_alignment/#Cost-Model","page":"Text Alignment","title":"Cost Model","text":"The pairwise alignment above works by minimizing a cost function, which is defined by a cost model. It is important that we understand how the cost model is setup so that we can give proper scoring for the mismatches, matches, deletions and insertions. To define a cost model, we use BioAligments.jl's CostModel struct.\n\nThe default cost model is given by\n\nusing BioAlignments\ncostmodel = CostModel(match=0, mismatch=1, insertion=1, deletion=1)\n\nnote: Interpretation of CostModel\nThe instantiated costmodel above tells us that, if a matched happened between the characters of the reference and the target texts, we set it to 0. Otherwise, that is, if mismatch, insertions or deletions happened, then the distance is 1.\n\nnote: Optimization of the Alignment\nThe alignment is optimized by minimizing the cost function defined by the cost model, by prioritizing matches since it gives the algorithm a lower distance (which is 0)\n\nIf we set the costmodel to the following,\n\nusing BioAlignments\ncostmodel = CostModel(match=0, mismatch=10, insertion=3, deletion=1)\n\nThen if a mismatch happened, the algorithm will instead consider it a deletion as much as possible to avoid a distance score of 10 (for mismatch) and go for a distance of 1 (for deletion) instead.\n\nConsider the following example,\n\nusing Yunir\n@transliterator :default\netgt = Ar(\"رضي الله عنه\")\neref = Ar(\"صلي الله عليه وسلم\")\nmapping = Dict(\"الله\" => \"ﷲ\",)\netgt_nrm = normalize(etgt, mapping)\neref_nrm = normalize(eref, mapping)\ncostmodel = CostModel(match=0, mismatch=1, insertion=1, deletion=1);\nres_c1 = align(encode(eref_nrm), encode(etgt_nrm), costmodel=costmodel)\nres_c1\n\nNow, compare the result if we increased the mismatch and insertion in the cost model.\n\ncostmodel = CostModel(match=0, mismatch=10, insertion=5, deletion=1)\nres_c2 = align(encode(eref_nrm), encode(etgt_nrm), costmodel=costmodel)\nres_c2\n\nYou can copy and paste the result to any text editor with Arabic monospace, like in Notepad++ screenshot above to see the alignment properly.\n\nYou will notice that, in res_c1 above we have 3 mismatches, but in res_c2 the algorithm avoided assigning mismatches and instead prioritized deletions and insertions. This can be confirmed below:\n\ncount_mismatches(res_c1)\ncount_deletions(res_c1)\ncount_insertions(res_c1)\ncount_mismatches(res_c2)\ncount_deletions(res_c2)\ncount_insertions(res_c2)","category":"section"},{"location":"assets/kawkab-mono-0.500 2/release-notes/#Kawkab-Mono-كوكب-مونو","page":"Kawkab Mono كوكب مونو","title":"Kawkab Mono كوكب مونو","text":"","category":"section"},{"location":"assets/kawkab-mono-0.500 2/release-notes/#Release-Notes","page":"Kawkab Mono كوكب مونو","title":"Release Notes","text":"","category":"section"},{"location":"assets/kawkab-mono-0.500 2/release-notes/#v0.500-2015-12-17","page":"Kawkab Mono كوكب مونو","title":"v0.500 - 2015-12-17","text":"Font is now paired with Source Code Pro instead of PT Mono. Source Code Pro makes available its Masters files so this allows us to precisely choose and interpolate the most suitable weight for pairing non-Arabic glyphs with Arabic ones.\nCreated a Light design master.\nFont is available in 3 weights: Light, Regular and Bold.\nPrevious Regular weight is now reclassified as Bold.\nImproved س and ص glyphs.\nVarious outline improvements to several other glyphs.\nAdded release-notes.md (this file).","category":"section"},{"location":"assets/kawkab-mono-0.500 2/release-notes/#v0.101-2015-11-10","page":"Kawkab Mono كوكب مونو","title":"v0.101 - 2015-11-10","text":"Initial public release.\nImproved metadata and license information for PT Mono.","category":"section"},{"location":"man/orthography/#Orthographical-Analysis","page":"Orthographical Analysis","title":"Orthographical Analysis","text":"All Arabic characters and diacritics and other characters used in Arabic texts, such as the Qur'an are all encoded as structs or types. These types have properties that can be used for orthographical analysis. These properties are the vocal and numeral associated with each of the character.","category":"section"},{"location":"man/orthography/#Numerals","page":"Orthographical Analysis","title":"Numerals","text":"The numerals we refer here is the Abjad numeral.\n\nusing Yunir\n@transliterator :default\n\nar_basmala = Ar(\"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\");\n\nIf we want to take the numerals, we need to tokenize it first.\n\narb_token = tokenize(ar_basmala)\n\nNext, we parse each of these words as Orthography.\n\narb_parsed1 = parse(Orthography, arb_token[1])\narb_parsed2 = parse.(Orthography, arb_token)\n\nFinally, we can compute the numerals of the parsed tokens as follows:\n\nnumerals(arb_parsed2[1])\nnumerals(arb_parsed2[2])\nnumerals(arb_parsed2[3])\n\nWe can also check the type of the characters, whether it is a Lunar or Solar character. To do this, use the isfeat (short for 'is feature' in the sense that characters here are also referred as feature).\n\nisfeat(arb_parsed2[1], AbstractLunar)\narb_parsed2[1][isfeat(arb_parsed2[1], AbstractLunar)]\nisfeat.(arb_parsed2, AbstractLunar)\nisfeat.(arb_parsed2, AbstractSolar)","category":"section"},{"location":"man/orthography/#Vocals","page":"Orthographical Analysis","title":"Vocals","text":"Vocals refer to categorization of the characters based on the vocals it mainly uses in pronunciation.\n\nvocals(arb_parsed2[1])\nvocals(arb_parsed2[2])\nvocals(arb_parsed2[3])","category":"section"},{"location":"man/orthography/#Simple-Encoding","page":"Orthographical Analysis","title":"Simple Encoding","text":"Simple encoding is a worded or spelled out transliteration of an Arabic text.\n\nparse(SimpleEncoding, ar_basmala)","category":"section"},{"location":"man/basic_utilities/#Basic-Utilities","page":"Basic Utilities","title":"Basic Utilities","text":"In this section, we are going to discuss how to use the APIs for dediacritization, normalization, and transliteration.","category":"section"},{"location":"man/basic_utilities/#Dediacritization","page":"Basic Utilities","title":"Dediacritization","text":"Dediacritization is the process of removing diacritics from an Arabic word. These diacritics are mostly vowels but also includes sukuun سُكُون  and saddah شَدّة. The function to use for dediacritization is dediac which works on either Arabic, Buckwalter or custom transliterated characters.\n\nusing Yunir\n@transliterator :default\n\nar_basmala = Ar(\"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\");\ndediac(ar_basmala)\n\nOr using Buckwalter as follows:\n\nbw_basmala = Bw(\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\");\ndediac(bw_basmala; isarabic=false)\n\nThe isarabic parameter with false argument indicates that the dediac function or dediac API takes a Buckwalter encoded input, bw_basmala, and returns an output that is not encoded in Arabic (as in the previous example) but instead an output in Buckwalter form as well. \n\nWith Julia's broadcasting feature, the above dediacritization can be applied to arrays by simply adding . to the name of the function.\n\nsentence0 = Ar.([\"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\",\n    \"إِيَّاكَ نَعْبُدُ وَإِيَّاكَ نَسْتَعِينُ\"\n])\ndediac.(sentence0)\n\nAs seen above, broadcasting allows application of the dediac function to the elements of the vector sentence0. That is, because there are two entries in the sentence0 vector, the broadcasting applies the dediac function to each of these and thus returning two outputs as well.","category":"section"},{"location":"man/basic_utilities/#Normalization","page":"Basic Utilities","title":"Normalization","text":"Arabic letters are calligraphic by design. It's free flowing design makes it very flexible to form unique ligatures that may require normalization for consistency's sake when doing natural language processing. To do normalization, the function to use is normalize, which works on either Arabic, Buckwalter or custom transliterated characters. For example, using the ar_basmala and bw_basmala defined above, the normalized version would be\n\nnormalize(ar_basmala)\nnormalize(bw_basmala)\n\nAgain, the isarabic=false parameter simply disables an Arabic output and instead encode it as a Buckwalter output. You can also normalize specific characters, for example:\n\nnormalize(ar_basmala, :alif_khanjareeya)\nnormalize(ar_basmala, :hamzat_wasl)\nsentence1 = Ar(\"وَٱلَّذِينَ يُؤْمِنُونَ بِمَآ أُنزِلَ إِلَيْكَ وَمَآ أُنزِلَ مِن قَبْلِكَ وَبِٱلْءَاخِرَةِ هُمْ يُوقِنُونَ\");\nnormalize(sentence1, :alif_maddah)\nnormalize(sentence1, :alif_hamza_above)\nsentence2 = Ar(\"إِيَّاكَ نَعْبُدُ وَإِيَّاكَ نَسْتَعِينُ\");\nnormalize(sentence2, :alif_hamza_below)\nsentence3 = Ar(\"ٱلَّذِينَ يُؤْمِنُونَ بِٱلْغَيْبِ وَيُقِيمُونَ ٱلصَّلَوٰةَ وَمِمَّا رَزَقْنَٰهُمْ يُنفِقُونَ\");\nnormalize(sentence3, :waw_hamza_above)\nnormalize(sentence3, :ta_marbuta)\nsentence4 = Ar(\"ٱللَّهُ يَسْتَهْزِئُ بِهِمْ وَيَمُدُّهُمْ فِى طُغْيَٰنِهِمْ يَعْمَهُونَ\");\nnormalize(sentence4, :ya_hamza_above)\nsentence5 = Ar(\"ذَٰلِكَ ٱلْكِتَٰبُ لَا رَيْبَ فِيهِ هُدًى لِّلْمُتَّقِينَ\");\nnormalize(sentence5, :alif_maksura)\nsentence6 = Ar(\"ﷺ\")\nnormalize(sentence6) === Ar(\"صلى الله عليه وسلم\")\nsentence7 = Ar(\"ﷻ\")\nnormalize(sentence7) === Ar(\"جل جلاله\")\nsentence8 = Ar(\"﷽\")\nnormalize(sentence8) === ar_basmala\n\nOr a combination,\n\nnormalize(ar_basmala, [:alif_khanjareeya, :hamzat_wasl])\n\nBroadcasting also applies to normalize function.\n\nnormalize.(sentence0)\nnormalize.(sentence0, [:alif_khanjareeya, :alif_hamza_below])","category":"section"},{"location":"man/basic_utilities/#Transliteration","page":"Basic Utilities","title":"Transliteration","text":"By default, Yunir.jl uses extended Buckwalter transliteration. The function to use are encode (Arabic -> Roman) and arabic (Roman -> Arabic). The following are some examples:\n\narabic(bw_basmala)\narabic(bw_basmala) === ar_basmala\nencode(ar_basmala)\nencode(ar_basmala) === bw_basmala","category":"section"},{"location":"man/basic_utilities/#Custom-Transliteration","page":"Basic Utilities","title":"Custom Transliteration","text":"For custom transliteration, user must specify the character mapping in a dictionary with Symbol type for both keys and values. By default, the Buckwalter mapping used in Yunir.jl is encoded in the constant variable BW_ENCODING.\n\nBW_ENCODING\n\nSuppose we want to create a custom transliteration by simply reversing the values of the dictionary, then we have the following:\n\nold_keys = collect(keys(BW_ENCODING));\nnew_vals = reverse(collect(values(BW_ENCODING)));\n\nThe new dictionary would be:\n\nmy_encoder = Dict(old_keys .=> new_vals)\n\nNext is to declare this new transliteration so functions for dediacritization and normalization can use the new mapping. This is done using the macro @transliterator, which takes two arguments: the dictionary and the type name of the mapping.\n\n@transliterator my_encoder \"MyEncoder\"\n\nUsing this new transliteration, we now have an updated mapping for the basmala above:\n\nencode(ar_basmala)\n\nReversing this two Arabic characters should give us the appropriate decoding:\n\narabic(encode(ar_basmala))","category":"section"},{"location":"man/basic_utilities/#Dediacritization-and-Normalization-on-Custom-Transliteration","page":"Basic Utilities","title":"Dediacritization and Normalization on Custom Transliteration","text":"As mentioned above, dediacritization and normalization also works on new custom transliteration. For example, dediacritizing the encoded ar_basmala would give us:\n\ndediac(encode(ar_basmala))\n\ndediac(encode(ar_basmala)) |> arabic\n\nAnd for normalization, \n\nnormalize(encode(ar_basmala))\n\nnormalize(encode(ar_basmala)) |> arabic","category":"section"},{"location":"man/basic_utilities/#Reset-Transliteration","page":"Basic Utilities","title":"Reset Transliteration","text":"To reset the transliteration back to Buckwalter, simply specify :default as the argument for the macro @transliterator as follows:\n\n@transliterator :default\n\nWith this, all functions dependent on transliteration will also get updated.\n\nencode(ar_basmala)\nencode(ar_basmala) === bw_basmala\ndediac(encode(ar_basmala))\nnormalize(encode(ar_basmala))","category":"section"},{"location":"man/references/#References","page":"References","title":"References","text":"A.-A. B. Asaad. Text Analytics of the Qur'ān. Master's thesis, University of the Philippines (06 2025).\n\n\n\nR. Farrin. Structure and Qur'anic Interpretation: A Study of Symmetry and Coherence in Islam's Holy Text. Islamic Encounter (White Cloud Press, 2014).\n\n\n\n","category":"section"},{"location":"#Welcome-to-Yunir.jl-Documentation","page":"Home","title":"Welcome to Yunir.jl Documentation","text":"(Image: codecov) (Image: MIT License) (Image: DOI)\n\nYunir.jl is a toolkit for Arabic Natural Language Processing (ANLP). It offers APIs for the building blocks of ANLP specifically dediacritization, normalization, transliteration (including custom transliteration), simple encoding, and orthographical analysis. It also has advanced capabilities for doing text alignment, rhythmic analysis and textual symmetry analysis. Lastly, it supports QuranTree.jl.\n\nYunir (ينير) /yunīr/ is the Arabic word for \"illuminate.\" The logo is a Kufic calligraphy of the Arabic word نور /nūr/ or \"light,\" specifically, a heatless light such as that of the light of the moon.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package, run the following:\n\njulia> using Pkg\njulia> Pkg.add(\"Yunir\")","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"@software{al_ahmadgaid_b_asaad_2022_6629868,\n  author       = {Al-Ahmadgaid B. Asaad},\n  title        = {{Yunir.jl: A lightweight Arabic NLP toolkit for \n                   Julia}},\n  month        = jun,\n  year         = 2022,\n  publisher    = {Zenodo},\n  version      = {v0.2.0},\n  doi          = {10.5281/zenodo.6629868},\n  url          = {https://doi.org/10.5281/zenodo.6629868}\n}","category":"section"},{"location":"man/api/#API-References","page":"API","title":"API References","text":"","category":"section"},{"location":"man/api/#Yunir.AbstractRhythmicVisArgs","page":"API","title":"Yunir.AbstractRhythmicVisArgs","text":"AbstractRhythmicVisArgs\n\nAbstract base type for rhythmic visualization arguments. Concrete subtypes define specific visualization configurations.\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.AbstractSyllable","page":"API","title":"Yunir.AbstractSyllable","text":"AbstractSyllable\n\nAbstract base type for syllable representations used in rhythmic analysis.\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.AyahEmbeddings","page":"API","title":"Yunir.AyahEmbeddings","text":"Ayah Embeddings Type\n\nparams:     numslices - number of slices     varslices - variability of slices, parameter for Dirichlet distribution\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.AyahMidpoints","page":"API","title":"Yunir.AyahMidpoints","text":"Midpoints Generator\n\nparams:     n_ayahs - total number of ayahs     n - number of samples of slices to generate     slicer - Slicer configuration\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.Harakaat","page":"API","title":"Yunir.Harakaat","text":"Harakaat(char::Union{String, Char}, is_tanween::Bool)\n\nCreate a Harakaat object using char as the Arabic orthography, which is expected to be the  short vowels, sukūn, and tanween.\n\njulia> fatha = arabic(\"a\")\njulia> Harakaat(fatha, false)\nHarakaat(\"َ\", false)\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.LastRecited","page":"API","title":"Yunir.LastRecited","text":"LastRecited <: AbstractRhythmicVisArgs\n\nConfiguration for last recited syllable visualization.\n\nFields\n\nvariant::LastRecitedVariants: Specifies the visualization variant (A, B, or C) which determines how many subplots to create and what syllable components to display.\n\nExamples\n\n# Create with variant A (single subplot)\nlr = LastRecited(A)\n\n# Create with variant B (two subplots)\nlr = LastRecited(B)\n\n# Create with variant C (three subplots)\nlr = LastRecited(C)\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.LastRecited-Tuple{}","page":"API","title":"Yunir.LastRecited","text":"LastRecited()\n\nCreate a LastRecited object with default variant A (single subplot showing only the last syllable).\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.LastRecitedSyllable","page":"API","title":"Yunir.LastRecitedSyllable","text":"LastRecitedSyllable <: AbstractSyllable\n\nRepresents a syllable extracted from the end of a text in Buckwalter transliteration.\n\nFields\n\nsyllable::Bw: The syllable in Buckwalter encoding\n\nExamples\n\nsyllable = LastRecitedSyllable(Bw(\"mA\"))\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.LastRecitedVariants","page":"API","title":"Yunir.LastRecitedVariants","text":"LastRecitedVariants\n\nEnum specifying the variant of last-recited visualization.\n\nVariants\n\nA: Single subplot showing only the last recited syllable\nB: Two subplots showing the syllable and the syllable with trailing consonant\nC: Three subplots showing the syllable, syllable with trailing consonant, and syllable with leading and trailing consonants\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.RState","page":"API","title":"Yunir.RState","text":"Rhythmic State\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.RhythmicVis","page":"API","title":"Yunir.RhythmicVis","text":"RhythmicVis(args::T) where T <: AbstractRhythmicVisArgs\n\nCreate a RhythmicVis object with the specified visualization type and arguments.\n\nArguments\n\nargs::T: Visualization arguments, must be a subtype of AbstractRhythmicVisArgs\n\nExamples\n\n# Create a visualization with default LastRecited arguments\nvis = RhythmicVis(LastRecited())\n\n# Create with specific variant\nvis = RhythmicVis(LastRecited(B))\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.RhythmicVis-Tuple{Vector{Bw}}","page":"API","title":"Yunir.RhythmicVis","text":"(r::RhythmicVis)(texts::Vector{Bw}; fig_kwargs...)\n\nGenerate a rhythmic visualization from an array of Bw-encoded texts.\n\nThis is a functor/callable method for RhythmicVis objects that analyzes the last recited syllables in each text and creates a visualization showing how they vary across the texts.\n\nArguments\n\ntexts::Vector{Bw}: Array of texts in Bw transliteration\nfig_kwargs...: Keyword arguments passed to the lines! plotting function (e.g., color, linewidth)\n\nReturns\n\nA tuple containing:\n\nMakie.Figure: The generated visualization figure\nData tuple: A tuple of 1-3 data tuples (depending on variant), where each element contains:\nVector{Int64}: Y-axis numeric positions for each text\nDict{LastRecitedSyllable,Int64}: Dictionary mapping unique syllables to their assigned positions\n\nThe number of data tuples returned depends on the variant:\n\nVariant A: 1-tuple of data\nVariant B: 2-tuple of data\nVariant C: 3-tuple of data\n\nExamples\n\n# Single subplot visualization\nvis = RhythmicVis(LastRecited(A))\nfig, ((positions, syllable_map),) = vis(buckwalter_texts)\n\n# Three subplot visualization\nvis = RhythmicVis(LastRecited(C))\nfig, (data1, data2, data3) = vis(buckwalter_texts, color=:blue)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.Schillinger","page":"API","title":"Yunir.Schillinger","text":"Schillinger <: AbstractRhythmicVisArgs\n\nA structure for visualizing rhythmic patterns using Joseph Schillinger's rhythmic graph theory.\n\nFields\n\nstate_timings::Dict{Bw,RState}: A dictionary mapping Buckwalter-encoded vowel patterns to rhythmic states with their durations and descriptions.\n\nExample\n\ntajweed_timings = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"),  # kasra\n    Bw(\"a\") => RState(1, \"short\"),  # fatha\n    Bw(\"u\") => RState(1, \"short\"),  # damma\n    Bw(\"iy\") => RState(2, \"long\"),  # kasra + yaa\n    Bw(\"aA\") => RState(2, \"long\"),  # fatha + alif\n    Bw(\"uw\") => RState(2, \"long\"),  # damma + waw\n    Bw(\"^\") => RState(4, \"maddah\")  # maddah\n)\n\nschillinger = Schillinger(tajweed_timings)\n\nSee also: rhythmic_states, vis\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.Segment","page":"API","title":"Yunir.Segment","text":"Segment(text::String, harakaat::Vector{Harakaat})\n\nCreate a Segment object from text, which is the form of the segments of syllables, where vowels of which are also listed as harakaat.\n\njulia> bw_segment = Bw(\"~aH?Hiy\")\njulia> Segment(bw_segment, Harakaat[Harakaat(Bw(\"a\"), false), Harakaat(Bw(\"i\"), false)])\nSegment(\"~aH?Hiy\", Harakaat[Harakaat(\"a\", false), Harakaat(\"i\", false)])\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.Slicer","page":"API","title":"Yunir.Slicer","text":"Slicer Configuration\n\nparams:     numslices - number of slices     varslices - variability of slices, parameter for Dirichlet distribution     dist_formula - distance metric for measuring similarity or distances of the slices\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.Syllabification","page":"API","title":"Yunir.Syllabification","text":"Rhyme(is_quran::Bool, syllable::Syllable)\n\nCreate a Rhyme object with specifics for the syllable contructed through Syllable.  It also takes argument for is_quran to handle Qur'an input, which does not recite the last vowel in every last word of the verse. The following code creates a Syllable, which specifies 3 syllables with 1 leading and trailing characters to include.\n\njulia> ar_raheem_alamiyn = [\"ٱلرَّحِيمِ\", \"ٱلْعَٰلَمِينَ\"]\n2-element Vector{String}:\n \"ٱلرَّحِيمِ\"\n \"ٱلْعَٰلَمِينَ\"\njulia> r = Syllabification(true, Syllable(1, 1, 3))\nRhyme(true, Syllable{Int64}(1, 1, 3))\njulia> output = r.(ar_raheem_alamiyn, true)\n2-element Vector{Segment}:\n Segment(\"َّح?حِي\", Harakaat[Harakaat(\"َ\", false), Harakaat(\"ِ\", false)])\n Segment(\"عَٰ?لَم?مِي\", Harakaat[Harakaat(\"َ\", false), Harakaat(\"َ\", false), Harakaat(\"ِ\", false)])\njulia> encode.(output)\n2-element Vector{Segment}:\n Segment(\"~aH?Hiy\", Harakaat[Harakaat(\"a\", false), Harakaat(\"i\", false)])\n Segment(\"Ea`?lam?miy\", Harakaat[Harakaat(\"a\", false), Harakaat(\"a\", false), Harakaat(\"i\", false)])\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.Syllabification-Tuple{Union{Ar, Bw}}","page":"API","title":"Yunir.Syllabification","text":"(r::Syllabification)(text::String, isarabic::Bool=false)\n\nCall function for the Syllabification object. It extracts the rhyme features of text using the options from the Syllabification object specified by r. It can handle both Arabic and Buckwalter input by toggling isarabic. \n\nNote: This will only work with @transliterator :default\n\njulia> ar_raheem = \"ٱلرَّحِيمِ\"\n\"ٱلرَّحِيمِ\"\njulia> r = Syllabification(true, Syllable(1, 2, 1))\nSyllabification(true, Syllable{Int64}(1, 2, 1))\njulia> output = r(ar_raheem, true)\nSegment(\"حِيم\", Harakaat[Harakaat(\"ِ\", false)])\njulia> encode(output)\nSegment(\"Hiym\", Harakaat[Harakaat(\"i\", false)])\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.Syllable","page":"API","title":"Yunir.Syllable","text":"Syllable{T <: Number}(\n    lead_nchars::T,\n    trail_nchars::T,\n    nvowels::T\n)\n\nCreate a Syllable object specifying the number of vowels nvowels to capture, and  also the number of leading (lead_nchars) and trailing characters (trail_nchars)  around the vowel. This object is used as an input for the Rhyme object. The following code creates a Syllable, which specifies 3 syllables with 1 leading and trailing characters to include.\n\njulia> Syllable(1, 1, 3)\nSyllable{Int64}(1, 1, 3)\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Yunir.align-Tuple{Bw, Bw}","page":"API","title":"Yunir.align","text":"align(src::String, tgt::String; costmodel::BioAlignments.CostModel=BioAlignments.CostModel(match=0, mismatch=1, insertion=1, deletion=1))\n\nAlign tgt string to src string using a particular costmodel from BioAlignments.jl.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.align-Tuple{Vector{Bw}, Vector{Bw}}","page":"API","title":"Yunir.align","text":"align(src::Vector{String}, tgt::Vector{String};\n\tcostmodel::CostModel=CostModel(match=0, mismatch=1, insertion=1, deletion=0),\n\tstore_results::Bool=true\n)\n\nALign tgt array of texts to src array of texts using a particular costmodel from BioAlignments.jl. store_results if results of alignment are stored or returned, otherwise, only the scores are returned.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.arabic-Tuple{Bw}","page":"API","title":"Yunir.arabic","text":"arabic(s::String[, encoder::AbstractEncoder])\n\nEncode the String object into Arabic characters. Custom encoder generated from @transliterator can be provided, but default is Buckwalter.\n\nExamples\n\njulia> bw_basmala = \"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"\njulia> arabic(bw_basmala)\n\"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.clean","page":"API","title":"Yunir.clean","text":"clean(s::String, replace_non_ar::String, target_regex::Regex)\n\nClean the input text by replacing all non-Arabic texts with a string input.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Yunir.crossover!-Union{Tuple{T}, Tuple{AyahMidpoints{T}, Float64}} where T<:Integer","page":"API","title":"Yunir.crossover!","text":"Parent's Chromosome Crossover\n\nThe parents chromosome are crossed-over \n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.dediac-Tuple{Union{Ar, Bw}}","page":"API","title":"Yunir.dediac","text":"dediac(s::String; isarabic::Bool=true)\n\nDediacritize the input String object.\n\nExamples\n\njulia> bw_basmala = \"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"\njulia> dediac(bw_basmala)\n\"bsm {llh {lrHmn {lrHym\"\njulia> dediac(arabic(bw_basmala))\n\"بسم ٱلله ٱلرحمن ٱلرحيم\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.encode-Tuple{Ar, AbstractEncoder}","page":"API","title":"Yunir.encode","text":"encode(s::Union{Char,String}, encoder::AbstractEncoder)\n\nTransliterate the input String object using a custom encoder. Custom encoder is generated using the @transliterator.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.encode-Tuple{Ar}","page":"API","title":"Yunir.encode","text":"encode(s::String)\n\nTransliterate the input String object using Buckwalter.\n\nExamples\n\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\njulia> encode(ar_basmala)\n\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.fitness-Union{Tuple{T}, Tuple{Array{Array{AyahEmbeddings{T}, 1}, 1}, Slicer}} where T<:Union{Float32, Float64}","page":"API","title":"Yunir.fitness","text":"Circular-wise Computation of the Distance of Slices\n\nparams:     five_nums - five number summaries     slicer - Slicer configuration     dist - a Distances UnionSemiMetric\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.five_summary-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"Yunir.five_summary","text":"Compute Five Number Summary\n\nfive_summary(v::Vector{T}) where T<:Union{Float32,Float64} params:     v - data (e.g. embeddings)\n\nfive_summary(slices::Vector{Vector{Matrix{T}}}) where T<:Union{Float32,Float64} params:     slices - slices of data (e.g. ayah embeddings)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.gen_slices-Union{Tuple{T}, Tuple{AyahEmbeddings{T}, AyahMidpoints}} where T<:Union{Float32, Float64}","page":"API","title":"Yunir.gen_slices","text":"Slices Generator\n\nparams:     ayahs_emb - the embeddings to slice     midpoints - the midpoints used for slicing\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.isfeat-Tuple{Orthography, Type{<:AbstractConsonant}}","page":"API","title":"Yunir.isfeat","text":"isfeat(x::Orthography, y::Type{<:AbstractConsonant})\n\nchecks if x is a y feature.\n\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\";\njulia> arb_token = tokenize(ar_basmala)\n4-element Vector{String}:\n \"بِسْمِ\"\n \"ٱللَّهِ\"\n \"ٱلرَّحْمَٰنِ\"\n \"ٱلرَّحِيمِ\"\njulia> arb_parsed2 = parse.(Orthography, arb_token)\n4-element Vector{Orthography}:\n Orthography(Type[Ba, Kasra, Seen, Sukun, Meem, Kasra])\n Orthography(Type[AlifHamzatWasl, Lam, Lam, Shadda, Fatha, Ha, Kasra])\n Orthography(Type[AlifHamzatWasl, Lam, Ra, Shadda, Fatha, HHa, Sukun, Meem, Fatha, AlifKhanjareeya, Noon, Kasra])\n Orthography(Type[AlifHamzatWasl, Lam, Ra, Shadda, Fatha, HHa, Kasra, Ya, Meem, Kasra])\njulia> isfeat(arb_parsed2[1], AbstractLunar)\n6-element BitVector:\n 1\n 0\n 0\n 0\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.last_syllable-Tuple{LastRecited, Bw}","page":"API","title":"Yunir.last_syllable","text":"last_syllable(lr::LastRecited, text::Bw)\n\nExtract the last syllable(s) from Buckwalter-encoded text according to the specified variant.\n\nThe function extracts different representations of the final syllable based on the variant:\n\nVariant A: Returns 1-tuple with just the last syllable (2 characters from end, positions end-3:end-2)\nVariant B: Returns 2-tuple with the syllable and syllable+trailing consonant (positions end-3:end-1)\nVariant C: Returns 3-tuple with syllable, syllable+trailing, and leading+syllable+trailing (positions end-4:end-1)\n\nArguments\n\nlr::LastRecited: Configuration specifying which variant to use\ntext::Bw: The Buckwalter-encoded text to extract from\n\nReturns\n\nA tuple of LastRecitedSyllable objects (1, 2, or 3 elements depending on variant)\n\nExamples\n\ntext = Bw(\"...mAno\")\nlr = LastRecited(A)\n(syl,) = last_syllable(lr, text)  # Returns 1-tuple\n\nlr = LastRecited(C)\n(syl, syl_trailing, full) = last_syllable(lr, text)  # Returns 3-tuple\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.normalize","page":"API","title":"Yunir.normalize","text":"normalize(s::String)\n\nNormalize a Arabic or Buckwalter String characters.\n\nExamples\n\njulia> normalize(\"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\")\n\"بِسْمِ اللَّهِ الرَّحْمَانِ الرَّحِيمِ\"\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Yunir.normalize-Tuple{Union{Ar, Bw}, Symbol}","page":"API","title":"Yunir.normalize","text":"normalize(s::String, char::Symbol; isarabic::Bool=true)\n\nNormalize a specific Arabic or Buckwalter String character (chars).\n\nExamples\n\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\njulia> normalize(ar_basmala, :alif_khanjareeya) === \"بِسْمِ ٱللَّهِ ٱلرَّحْمَانِ ٱلرَّحِيمِ\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.normalize-Tuple{Union{Ar, Bw}, Vector{Symbol}}","page":"API","title":"Yunir.normalize","text":"normalize(s::String, chars::Vector{Symbol}; isarabic::Bool=true)\n\nNormalize a specific Arabic or Buckwalter String character/s (chars).\n\nExamples\n\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\njulia> normalize(ar_basmala, [:alif_khanjareeya, :hamzat_wasl]) === \"بِسْمِ اللَّهِ الرَّحْمَانِ الرَّحِيمِ\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.rhythmic_states-Tuple{Schillinger, Union{Vector{Ar}, Vector{Bw}}}","page":"API","title":"Yunir.rhythmic_states","text":"rhythmic_states(data::Schillinger, texts::Vector{Bw}) -> Vector{Vector{RState}}\n\nAnalyzes Buckwalter-encoded Arabic texts and converts them into rhythmic states based on Schillinger's rhythmic theory.\n\nArguments\n\ndata::Schillinger: A Schillinger object containing the mapping of vowel patterns to rhythmic states.\ntexts::Vector{Bw}: A vector of Buckwalter-encoded Arabic text strings to analyze.\n\nReturns\n\nVector{Vector{RState}}: A vector where each element corresponds to a text input and contains the rhythmic states for each syllable in that text.\n\nDetails\n\nThe function performs the following steps:\n\nSplits each text into individual words\nApplies syllabification to each word:\nFirst word: first_word=true, silent_last_vowel=false\nLast word: first_word=false, silent_last_vowel=true\nMiddle words: first_word=false, silent_last_vowel=false\nMaps syllables to rhythmic states using the provided timing dictionary\n\nExample\n\ntajweed_timings = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"),\n    Bw(\"a\") => RState(1, \"short\"),\n    Bw(\"iy\") => RState(2, \"long\"),\n    Bw(\"aA\") => RState(2, \"long\")\n)\n\nschillinger = Schillinger(tajweed_timings)\ntexts = [Bw(\"bisomi {ll~ahi\")]\nstates = rhythmic_states(schillinger, texts)\n\nSee also: Schillinger, vis\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.selection-Union{Tuple{T}, Tuple{AyahEmbeddings, AyahMidpoints{T}, T, Slicer}} where T<:Integer","page":"API","title":"Yunir.selection","text":"Tournament Selection of Parent's Chromosome\n\nThe function selects the parent's chromosome using tournament selection\n\nparams:     ayahs_emb - Ayah embeddings     mp - Midpoints of the Ayah     k - The size of samples from where the parent is chosen\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.syllabic_consistency-Tuple{Vector{Segment}, Union{Dict{Ar, RState}, Dict{Bw, RState}}}","page":"API","title":"Yunir.syllabic_consistency","text":"syllabic_consistency(segments::Vector{Segment}, syllable_timings::Dict{Bw,RState})\n\nCompute syllabicconsistency from a given segments and `syllabletimings`. THIS WILL ONLY WORK IF THE VOWEL HAS ONLY 1 TRAIL\n\njulia> using Yunir\njulia> using QuranTree\njulia> crps, tnzl = load(QuranData());\njulia> crpstbl = table(crps)\njulia> tnzltbl = table(tnzl)\njulia> bw_texts = verses(tnzltbl[2])\njulia> texts = string.(split(bw_texts[1]))\njulia> r = Syllabification(true, Syllable(1, 0, 5))\njulia> segments = Segment[]\njulia> j = 1\njulia> for i in texts\n\t\t\tif j == 1\n\t\t\t\tpush!(segments, r(encode(i), first_word=true, silent_last_vowel=false))\n\t\t\telseif j == length(texts)\n\t\t\t\tpush!(segments, r(encode(i), first_word=false, silent_last_vowel=true))\n\t\t\telse\n\t\t\t\tpush!(segments, r(encode(i), first_word=false, silent_last_vowel=false))\n\t\t\tend\n\t\t\tj += 1\n\t\tend\njulia> tajweed_timings = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"), # kasra\n    Bw(\"a\") => RState(1, \"short\"), # fatha\n    Bw(\"u\") => RState(1, \"short\"), # damma\n    Bw(\"F\") => RState(1, \"short\"), # fatha tanween\n    Bw(\"N\") => RState(1, \"short\"), # damma tanween\n    Bw(\"K\") => RState(1, \"short\"), # kasra tanween\n    Bw(\"iy\") => RState(2, \"long\"), # kasra + yaa\n    Bw(\"aA\") => RState(2, \"long\"), # fatha + alif\n    Bw(\"uw\") => RState(2, \"long\"), # damma + waw\n    Bw(\"a`\") => RState(2, \"long\"),\n    Bw(\"^\") => RState(4, \"maddah\") # maddah\n)\n\njulia> syllabic_consistency(segments, tajweed_timings)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.to_numbers-Tuple{Vector{LastRecitedSyllable}}","page":"API","title":"Yunir.to_numbers","text":"to_numbers(texts::Vector{LastRecitedSyllable})\n\nConvert syllables to numeric y-axis positions for visualization.\n\nAssigns a unique integer to each unique syllable in the order of first appearance. This mapping is used to position syllables on the y-axis of the visualization plot.\n\nArguments\n\ntexts::Vector{LastRecitedSyllable}: Array of syllables to convert\n\nReturns\n\nA tuple containing:\n\nVector{Int64}: Numeric position for each syllable in texts (same length as input)\nDict{LastRecitedSyllable,Int64}: Dictionary mapping each unique syllable to its assigned position\n\nExamples\n\nsyllables = [syl1, syl2, syl1, syl3]  # syl1 appears twice\npositions, mapping = to_numbers(syllables)\n# positions = [1, 2, 1, 3]  # Same syllables get same position\n# mapping = Dict(syl1=>1, syl2=>2, syl3=>3)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.tokenize","page":"API","title":"Yunir.tokenize","text":"tokenize(s::String)\n\ntokenizes the string input s by space, and also tokenizes the punctuations.\n\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\njulia> tokenize(ar_basmala)\n4-element Vector{String}:\n \"بِسْمِ\"\n \"ٱللَّهِ\"\n \"ٱلرَّحْمَٰنِ\"\n \"ٱلرَّحِيمِ\"\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Yunir.vis","page":"API","title":"Yunir.vis","text":"vis(rhythms::Vector{Vector{RState}}, fig::Makie.Figure=Figure(size=(900,900)),\n    title::String=\"Title\", xlabel::String=\"Time in Seconds\", ylabel::String=\"Line\") -> Figure\n\nVisualizes Joseph Schillinger's rhythmic graph using a staircase plot.\n\nArguments\n\nrhythms::Vector{Vector{RState}}: A vector of rhythmic state sequences, typically output from rhythmic_states. Each inner vector represents the rhythmic pattern of one line/verse.\nfig::Makie.Figure: Optional pre-existing Makie Figure object. Defaults to a new Figure with size (900, 900).\ntitle::String: Title for the plot. Defaults to \"Title\".\nxlabel::String: Label for the x-axis. Defaults to \"Time in Seconds\".\nylabel::String: Label for the y-axis. Defaults to \"Line\".\n\nReturns\n\nMakie.Figure: A Makie Figure object containing the rhythmic visualization.\n\nDetails\n\nThe visualization creates a separate subplot for each input text, displaying the rhythmic pattern as a staircase plot where:\n\nEach step represents a rhythmic state\nThe width of each step corresponds to the duration of that state\nSteps alternate between two levels (0 and 1) to clearly show rhythmic changes\nAll subplots share the same x-axis for easy comparison\n\nExample\n\ntajweed_timings = Dict{Bw,RState}(\n    Bw(\"i\") => RState(1, \"short\"), # kasra\n    Bw(\"a\") => RState(1, \"short\"), # fatha\n    Bw(\"u\") => RState(1, \"short\"), # damma\n    Bw(\"F\") => RState(1, \"short\"), # fatha tanween\n    Bw(\"N\") => RState(1, \"short\"), # damma tanween\n    Bw(\"K\") => RState(1, \"short\"), # kasra tanween\n    Bw(\"iy\") => RState(2, \"long\"), # kasra + yaa\n    Bw(\"aA\") => RState(2, \"long\"), # fatha + alif\n    Bw(\"uw\") => RState(2, \"long\"), # damma + waw\n    Bw(\"a`\") => RState(2, \"long\"),\n    Bw(\"^\") => RState(4, \"maddah\") # maddah\n)\n\nbw_texts = [\n    Bw(\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"{loHamodu lil~ahi rab~i {loEa`lamiyna\"),\n    Bw(\"{lr~aHoma`ni {lr~aHiymi\"),\n    Bw(\"ma`liki yawomi {ld~iyni\"),\n    Bw(\"<iy~aAka naEobudu wa<iy~aAka nasotaEiynu\"),\n    Bw(\"{hodinaA {lS~ira`Ta {lomusotaqiyma\"),\n    Bw(\"Sira`Ta {l~a*iyna >anoEamota Ealayohimo gayori {lomagoDuwbi Ealayohimo walaA {lD~aA^l~iyna\")\n]\nrhythms = rhythmic_states(Schillinger(tajweed_timings), bw_texts)\nfig = vis(rhythms)\n\nSee also: Schillinger, rhythmic_states\n\n\n\n\n\n","category":"function"},{"location":"man/api/#Yunir.vis-Tuple{Vector{LastRecitedSyllable}, Vector{Int64}}","page":"API","title":"Yunir.vis","text":"vis(x1::Vector{LastRecitedSyllable}, y1::Vector{Int64}; kwargs...)\n\nCreate a Makie figure visualizing the progression of last recited syllables across texts.\n\nThe function creates 1-3 vertically stacked subplots depending on which optional data arguments are provided. Each subplot shows a line plot tracking how the last recited syllable patterns change across the sequence of texts.\n\nArguments\n\nx1::Vector{LastRecitedSyllable}: Syllable data for the first (required) subplot\ny1::Vector{Int64}: Numeric y-axis positions for the first subplot\n\nKeyword Arguments\n\nx2::Union{Nothing,Vector{LastRecitedSyllable}}=nothing: Optional syllable data for second subplot\ny2::Union{Nothing,Vector{Int64}}=nothing: Optional y-axis positions for second subplot\nx3::Union{Nothing,Vector{LastRecitedSyllable}}=nothing: Optional syllable data for third subplot\ny3::Union{Nothing,Vector{Int64}}=nothing: Optional y-axis positions for third subplot\nfig::Makie.Figure=Makie.Figure(resolution=(800, 800)): The Makie figure to draw into\ntitle::String=\"Title\": Title displayed at the top of the figure\nxlabel::String=\"Line Index\": Label for the x-axis\nylabel::Vector{String}: Y-axis labels for up to 3 subplots (defaults to syllable descriptions)\nfig_kwargs...: Additional keyword arguments passed to the lines! function\n\nReturns\n\nMakie.Figure: The figure with rendered visualization\n\nSubplot Behavior\n\nIf only x1/y1 provided: Creates single subplot\nIf x1/y1 and x2/y2 provided: Creates 2 vertically stacked subplots\nIf all x1/y1, x2/y2, and x3/y3 provided: Creates 3 vertically stacked subplots\n\nExamples\n\n# Single subplot\nfig = vis(syllables1, positions1, title=\"Last Syllable Analysis\")\n\n# Two subplots\nfig = vis(syllables1, positions1, x2=syllables2, y2=positions2)\n\n# Three subplots with custom styling\nfig = vis(syllables1, positions1,\n          x2=syllables2, y2=positions2,\n          x3=syllables3, y3=positions3,\n          title=\"Complete Analysis\",\n          color=:blue, linewidth=2)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Yunir.@transliterator-Tuple{Any, Any}","page":"API","title":"Yunir.@transliterator","text":"@transliterator(dict, name)\n\nCreate a custom transliterator using an input dict (Dict object) with its corresponding name as String object. This will automatically update the transliterator inside all  functions like arabic, verses, and encode.\n\nExamples\n\njulia> my_encoder = Dict(\n    Symbol(Char(0x0621)) => Symbol('('),\n    Symbol(Char(0x0622)) => Symbol('''),\n    Symbol(Char(0x0623)) => Symbol('&'),\n    Symbol(Char(0x0624)) => Symbol('>'),\n    Symbol(Char(0x0625)) => Symbol('}'),\n    Symbol(Char(0x0626)) => Symbol('<'),\n    Symbol(Char(0x0627)) => Symbol('b'),\n    Symbol(Char(0x0628)) => Symbol('A'),\n    Symbol(Char(0x0629)) => Symbol('t'),\n    Symbol(Char(0x062A)) => Symbol('p'),\n    Symbol(Char(0x062B)) => Symbol('j'),\n    Symbol(Char(0x062C)) => Symbol('v'),\n    Symbol(Char(0x062D)) => Symbol('x'),\n    Symbol(Char(0x062E)) => Symbol('H'),\n    Symbol(Char(0x062F)) => Symbol('*'),\n    Symbol(Char(0x0630)) => Symbol('d'),\n    Symbol(Char(0x0631)) => Symbol('z'),\n    Symbol(Char(0x0632)) => Symbol('r'),\n    Symbol(Char(0x0633)) => Symbol('$'),\n    Symbol(Char(0x0634)) => Symbol('s'),\n    Symbol(Char(0x0635)) => Symbol('D'),\n    Symbol(Char(0x0636)) => Symbol('S'),\n    Symbol(Char(0x0637)) => Symbol('Z'),\n    Symbol(Char(0x0638)) => Symbol('T'),\n    Symbol(Char(0x0639)) => Symbol('g'),\n    Symbol(Char(0x063A)) => Symbol('E'),\n    Symbol(Char(0x0640)) => Symbol('f'),\n    Symbol(Char(0x0641)) => Symbol('_'),\n    Symbol(Char(0x0642)) => Symbol('k'),\n    Symbol(Char(0x0643)) => Symbol('q'),\n    Symbol(Char(0x0644)) => Symbol('m'),\n    Symbol(Char(0x0645)) => Symbol('l'),\n    Symbol(Char(0x0646)) => Symbol('h'),\n    Symbol(Char(0x0647)) => Symbol('n'),\n    Symbol(Char(0x0648)) => Symbol('Y'),\n    Symbol(Char(0x0649)) => Symbol('w'),\n    Symbol(Char(0x064A)) => Symbol('F'),\n    Symbol(Char(0x064B)) => Symbol('y'),\n    Symbol(Char(0x064C)) => Symbol('K'),\n    Symbol(Char(0x064D)) => Symbol('N'),\n    Symbol(Char(0x064E)) => Symbol('u'),\n    Symbol(Char(0x064F)) => Symbol('a'),\n    Symbol(Char(0x0650)) => Symbol('~'),\n    Symbol(Char(0x0651)) => Symbol('i'),\n    Symbol(Char(0x0652)) => Symbol('^'),\n    Symbol(Char(0x0653)) => Symbol('o'),\n    Symbol(Char(0x0654)) => Symbol('`'),\n    Symbol(Char(0x0670)) => Symbol('#'),\n    Symbol(Char(0x0671)) => Symbol(':'),\n    Symbol(Char(0x06DC)) => Symbol('{'),\n    Symbol(Char(0x06DF)) => Symbol('\"'),\n    Symbol(Char(0x06E0)) => Symbol('@'),\n    Symbol(Char(0x06E2)) => Symbol(';'),\n    Symbol(Char(0x06E3)) => Symbol('['),\n    Symbol(Char(0x06E5)) => Symbol('.'),\n    Symbol(Char(0x06E6)) => Symbol(','),\n    Symbol(Char(0x06E8)) => Symbol('-'),\n    Symbol(Char(0x06EA)) => Symbol('!'),\n    Symbol(Char(0x06EB)) => Symbol('%'),\n    Symbol(Char(0x06EC)) => Symbol('+'),\n    Symbol(Char(0x06ED)) => Symbol(']')\n);\njulia> @transliterator my_encoder \"MyEncoder\"\njulia> encode(ar_basmala)\n\"A~$^l~ :mmiun~ :mziux^lu#h~ :mziux~Fl~\"\n\n\n\n\n\n","category":"macro"},{"location":"man/api/#Yunir.@transliterator-Tuple{Any}","page":"API","title":"Yunir.@transliterator","text":"@transliterator(symbl)\n\nFallback to the default Buckwalter transliterator.\n\njulia> @transliterator :default\njulia> ar_basmala = \"بِسْمِ ٱللَّهِ ٱلرَّحْمَٰنِ ٱلرَّحِيمِ\"\njulia> encode(ar_basmala)\n\"bisomi {ll~ahi {lr~aHoma`ni {lr~aHiymi\"\n\n\n\n\n\n","category":"macro"}]
}
